# BOJ_3055_탈출

## 문제 보기

---

해당 문제를 간략히 설명하겠습니다. R의 행과 C의 열로 이루어진 행렬에 고슴도치(S)가 살고 있습니다. 고슴도치는 행렬에 D(비버의 굴)로 이동하려고 합니다. 하지만 행렬에는 물이 있습니다. 물은 *로 나타냅니다. 물은 점점 차고있습니다. 그리고 X라는 바위가 있는데 X로는 고슴도치와 물 모두 이동할 수 없습니다. 그리고 일반 지역의 경우 . 로 나타냅니다. 물이 인접해있는 칸을 물* 표시로 변경합니다. 그리고 다음 턴에 고슴도치가 한칸 이동할 수 있습니다. 고슴도치가 물이 찬 곳을 이동할 수 없다고 가정할 때 고슴도치가 최단 경로로 이동하였을 때 최소 거리를 구하는게 이번 문제입니다. 참고로 R과 C는 50보다 작거나 같은 자연수 입니다. 고슴도치가 비버의 굴로 이동할 수 업슬경우 KAKTUS를 출력합니다.

## 문제 이해

---

 해당 문제를 보면 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하라는 구문이 있습니다. 최소의 시간 최단 거리라는 단어가 나올 때 BFS사용을 생각해 볼 수 있습니다. BFS는 최단 거리로 이동하는 특징이 있기 때문이죠 

문제의 입력을 살펴 보겠습니다.

```
5 4
.D.*
....
..X.
S.*.
....
```

아래와 같은 방식으로 입력이 들어오게 됩니다. * 표시가 물이라고 말씀 드렸었는데 현재 물이 2군대나 있습니다. 이러한 경우 일반적으로 BFS만 알고 있다면 해결하기 곤란할 수 있습니다. 이때 MULTI BFS라는 것을 사용할 수 있습니다. 

**MULTI BFS**

- 시작점이 많을 경우 행렬 전체를 탐색하면서 Queue에 해당 시작점을 모두 먼저 넣고 BFS를 돌리는 방식

## 문제 풀이

---

문제에서는 물이 먼저 이동하고 고슴도치가 다음으로 이동한다고 하였습니다. 처음에는 물을 이동시키고 다음으로 고슴도치를 이동 시키려고 생각을 해보았습니다. 하지만 BFS 구현을 생각해보면 물이 모든 이동을 마치는 시점이 언제인지 알기가 어렵습니다. 그래서 생각할 수 있는 방식이 물의 이동을 BFS로 돌리면서 몇번 이동하였는가를 행렬로 만드는 water_Distance 행렬을 만드는 것입니다. 물의 이동을 BFS로 굴리고 water_distance라는 행렬을 받는가 가정하면 아래의 입력으로 아래 결과를 확인할 수 있습니다.

```
3 3
D.*
...
.S.
```

물의 이동 경로 비버의 굴로 물이 들어갈 수 없음으로 초기값 -1이 들어가있습니다.

| -1 | 1 | 0 |
| --- | --- | --- |
| 3 | 2 | 1 |
| 4 | 3 | 2 |

물의 이동을 순서로 확인 할 수 있으니 고슴도치가 물에 빠지지 않고 비버의 굴로 갈 수 있는지 확인할 수 있게 되었습니다. 고슴도치가 다음으로 이동할 행을 선택할 때 물 이동 경로 배열의 값보다 작으면 물 보다 먼저 이동한 것입니다. 이런 식으로 비교하여 고슴도치가 비버의 숲으로 간 최단 경로의 길이를 확인할 수 있습니다.